package mapreduce

import "container/list"
import "fmt"

const (
      Idle = "Idle"
      InProgress = "In Progress"
      Success = "Success"
      Failure = "Failure"
)

type WorkerInfo struct {
  address string
  // You can add definitions here.
  status string
  jobID int
}


// Clean up all workers by sending a Shutdown RPC to each one of them Collect
// the number of jobs each work has performed.
func (mr *MapReduce) KillWorkers() *list.List {
  l := list.New()
  for _, w := range mr.Workers {
    DPrintf("DoWork: shutdown %s\n", w.address)
    args := &ShutdownArgs{}
    var reply ShutdownReply;
    ok := call(w.address, "Worker.Shutdown", args, &reply)
    if ok == false {
      fmt.Printf("DoWork: RPC %s shutdown error\n", w.address)
    } else {
      l.PushBack(reply.Njobs)
    }
  }
  return l
}

func (mr *MapReduce) GetFreeWorker() string {
     workerAddr := <- mr.registerChannel
     return workerAddr
     // todo see if we have any existing free workers
}

func (mr *MapReduce, jobNum int, jobType string) DispatchWorker() {
     workerAddr := GetFreeWorker(mr)
     mr.Workers[workerAddr] = WorkerInfo { workerAddr, InProgress, jobNum }
     args := &DoJobArgs { mr.file, jobType, jobNum, mr.nReduce }
     var reply DoJobReply
     ok := call(workerAddr, "Worker.DoJob", args, &reply)
     if ok == true {
     	mr.Workers[workerAddr].status = Success
     } else {
       mr.Workers[workerAddr].status = Failure
     }
     switch jobType {
     case Map:
     	  mr.mapperDoneChannel <- mr.Workers[workerAddr]
     case Reduce:
     	  mr.reducerDoneChannel <- mr.Workers[workerAddr]
     default: fmt.Println("should never get here...")
     }
}

// if jobType == Map, request nMap jobs on mapReqChannel
// else, if jobType == Reduce, request nReduce jobs on reduceReqChannel
func (mr *MapReduce jobType string) RequestJobs() {
     switch jobType {
     case Map:
     	  for i := 0; i < mr.nMap; i++ {
	      mr.mapReqChannel <- i
	  }
     case Reduce:
     	  for i := 0; i < mr.nReduce; i++ {
	      mr.reduceReqChannel <- i
	  }
     default: fmt.Println("invalid jobtype requested")
     }
}

func (mr *MapReduce) RunMaster() *list.List {
     numJobsDone := 0
     mr.mapReqChannel := make(chan int)
     mr.reduceReqChannel := make(chan int)
     mr.mapperDoneChannel := make(chan *WorkerInfo)
     mr.reducerDoneChannel := make(chan *WorkerInfo)

     // Request map jobs
     RequestJobs(mr, Map)

     for {
     select {
     case mapJobId := <- mr.mapReqChannel:
     	  go DispatchWorker(mr, mapJobId, Map)
     	  fmt.Println("received map request")
     case mapper := <- mr.mapperDoneChannel:
     	  if mapper.status == Success {
	     numJobsDone++
	     if (numJobsDone == mr.nMap) {
	     	numJobsDone = 0
	     	// dispatch reduce requests
		RequestJobs(mr, Reduce)
	     }
	  } else {
	     mr.mapReqChannel <- mapper.jobID
	  }
     case reduceJobId := <- mr.reduceReqChannel:
     	  go DispatchWorker(mr, reduceJobId, Reduce)
     	  fmt.Println("received reduce request")
     case reducer := <- mr.reducerDoneChannel:
     	  if reducer.status == Success {
	     numJobsDone++
	     if (numJobsDone == mr.nReduce) {
	     	// we're done
		return mr.KillWorkers()
	     }
	  } eles {
	    // it failed, retry
	    mr.reduceReqChannel <- reducer.jobID
	  }
     }
     }

}
